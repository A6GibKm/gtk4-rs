// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{
    keys::Key, AxisUse, CrossingMode, Device, Display, Drop, EventType, KeyMatch, ModifierType,
    NotifyType, ScrollDirection, Seat, Surface, TimeCoord, TouchpadGesturePhase,
};
use glib::translate::*;
use glib::{StaticType, Type};
use std::fmt;
use std::mem;

glib::wrapper! {
    #[derive(Debug)]
    pub struct Event(Shared<ffi::GdkEvent>);

    match fn {
        ref => |ptr| ffi::gdk_event_ref(ptr),
        unref => |ptr| ffi::gdk_event_unref(ptr),
    }
}

pub const NONE_EVENT: Option<&Event> = None;

impl StaticType for Event {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_event_get_type()) }
    }
}

impl Event {
    /*
    pub fn downcast<T: EventTypeTrait>(self) -> Result<T, Event> {
        unsafe {
            if self.get_type() == T::static_type() {
                Ok(from_glib_full(self.to_glib_full()))
            } else {
                Err(self)
            }
        }
    }

    pub fn downcast_ref<T: EventTypeTrait>(&self) -> Option<&T> {
        unsafe {
            if self.get_type() == T::static_type() {
                Some(&*(self as *const Event as *const T))
            } else {
                None
            }
        }
    } */

    pub fn get_axis(&self, axis_use: AxisUse) -> Option<f64> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gdk_event_get_axis(
                self.to_glib_none().0,
                axis_use.to_glib(),
                value.as_mut_ptr(),
            ));
            if ret {
                let value = value.assume_init();
                Some(value)
            } else {
                None
            }
        }
    }

    pub fn get_device(&self) -> Option<Device> {
        unsafe { from_glib_none(ffi::gdk_event_get_device(self.to_glib_none().0)) }
    }

    pub fn get_display(&self) -> Option<Display> {
        unsafe { from_glib_none(ffi::gdk_event_get_display(self.to_glib_none().0)) }
    }

    pub fn get_event_type(&self) -> EventType {
        unsafe { from_glib(ffi::gdk_event_get_event_type(self.to_glib_none().0)) }
    }

    pub fn get_history(&self) -> Vec<TimeCoord> {
        unsafe {
            let mut out_n_coords = mem::MaybeUninit::uninit();
            let ret = FromGlibContainer::from_glib_container_num(
                ffi::gdk_event_get_history(self.to_glib_none().0, out_n_coords.as_mut_ptr()),
                out_n_coords.assume_init() as usize,
            );
            ret
        }
    }

    pub fn get_modifier_state(&self) -> ModifierType {
        unsafe { from_glib(ffi::gdk_event_get_modifier_state(self.to_glib_none().0)) }
    }

    pub fn get_pointer_emulated(&self) -> bool {
        unsafe { from_glib(ffi::gdk_event_get_pointer_emulated(self.to_glib_none().0)) }
    }

    pub fn get_position(&self) -> Option<(f64, f64)> {
        unsafe {
            let mut x = mem::MaybeUninit::uninit();
            let mut y = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gdk_event_get_position(
                self.to_glib_none().0,
                x.as_mut_ptr(),
                y.as_mut_ptr(),
            ));
            if ret {
                let x = x.assume_init();
                let y = y.assume_init();
                Some((x, y))
            } else {
                None
            }
        }
    }

    pub fn get_seat(&self) -> Option<Seat> {
        unsafe { from_glib_none(ffi::gdk_event_get_seat(self.to_glib_none().0)) }
    }

    pub fn get_surface(&self) -> Option<Surface> {
        unsafe { from_glib_none(ffi::gdk_event_get_surface(self.to_glib_none().0)) }
    }

    pub fn get_time(&self) -> u32 {
        unsafe { ffi::gdk_event_get_time(self.to_glib_none().0) }
    }

    pub fn triggers_context_menu(&self) -> bool {
        unsafe { from_glib(ffi::gdk_event_triggers_context_menu(self.to_glib_none().0)) }
    }
}

impl fmt::Display for Event {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Event")
    }
}

pub trait EventTypeTrait: StaticType + FromGlibPtrFull<*mut ffi::GdkEvent> + 'static {}

macro_rules! define_event {
    ($rust_type:ident, $ffi_type:path, $ffi_type_path:path) => {
        // Can't use get_type here as this is not a boxed type but another fundamental type
        glib::wrapper! {
            #[derive(Debug)]
            pub struct $rust_type(Shared<$ffi_type>);

            match fn {

                ref => |ptr| ffi::gdk_event_ref(ptr as *mut ffi::GdkEvent) as *mut $ffi_type,
                unref => |ptr| ffi::gdk_event_unref(ptr as *mut ffi::GdkEvent),
            }
        }

        impl StaticType for $rust_type {
            fn static_type() -> Type {
                unsafe { from_glib($ffi_type_path()) }
            }
        }

        impl std::ops::Deref for $rust_type {
            type Target = Event;

            fn deref(&self) -> &Self::Target {
                unsafe { &*(self as *const $rust_type as *const Event) }
            }
        }

        impl EventTypeTrait for $rust_type {}

        #[doc(hidden)]
        impl FromGlibPtrFull<*mut ffi::GdkEvent> for $rust_type {
            unsafe fn from_glib_full(ptr: *mut ffi::GdkEvent) -> Self {
                from_glib_full(ptr as *mut $ffi_type)
            }
        }

        impl $rust_type {
            pub fn upcast(self) -> Event {
                unsafe { from_glib_full(self.to_glib_full() as *mut ffi::GdkEvent) }
            }

            pub fn upcast_ref(&self) -> &Event {
                &*self
            }
        }

        impl fmt::Display for $rust_type {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_str(stringify!($rust_type))
            }
        }
    };
}

define_event! {
    CrossingEvent,
    ffi::GdkCrossingEvent,
    ffi::gdk_crossing_event_get_type
}

impl CrossingEvent {
    #[doc(alias = "gdk_crossing_event_get_detail")]
    pub fn get_detail(&self) -> NotifyType {
        unsafe { from_glib(ffi::gdk_crossing_event_get_detail(self.to_glib_none().0)) }
    }

    #[doc(alias = "gdk_crossing_event_get_focus")]
    pub fn get_focus(&self) -> bool {
        unsafe { from_glib(ffi::gdk_crossing_event_get_focus(self.to_glib_none().0)) }
    }

    #[doc(alias = "gdk_crossing_event_get_mode")]
    pub fn get_mode(&self) -> CrossingMode {
        unsafe { from_glib(ffi::gdk_crossing_event_get_mode(self.to_glib_none().0)) }
    }
}

define_event! {
    ButtonEvent,
    ffi::GdkButtonEvent,
    ffi::gdk_button_event_get_type
}

impl ButtonEvent {
    #[doc(alias = "gdk_button_event_get_button")]
    pub fn get_button(&self) -> u32 {
        unsafe { ffi::gdk_button_event_get_button(self.to_glib_none().0) }
    }
}

define_event! {
    DeleteEvent,
    ffi::GdkDeleteEvent,
    ffi::gdk_delete_event_get_type
}

define_event! {
    DNDEvent,
    ffi::GdkDNDEvent,
    ffi::gdk_dnd_event_get_type
}
impl DNDEvent {
    #[doc(alias = "gdk_dnd_event_get_drop")]
    pub fn get_drop(&self) -> Option<Drop> {
        unsafe { from_glib_none(ffi::gdk_dnd_event_get_drop(self.to_glib_none().0)) }
    }
}

define_event! {
    FocusEvent,
    ffi::GdkFocusEvent,
    ffi::gdk_focus_event_get_type
}

impl FocusEvent {
    #[doc(alias = "gdk_focus_event_get_in")]
    pub fn get_in(&self) -> bool {
        unsafe { from_glib(ffi::gdk_focus_event_get_in(self.to_glib_none().0)) }
    }
}

define_event! {
    GrabBrokenEvent,
    ffi::GdkGrabBrokenEvent,
    ffi::gdk_grab_broken_event_get_type
}

impl GrabBrokenEvent {
    #[doc(alias = "gdk_grab_broken_event_get_grab_surface")]
    pub fn get_grab_surface(&self) -> Option<Surface> {
        unsafe {
            from_glib_none(ffi::gdk_grab_broken_event_get_grab_surface(
                self.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "gdk_grab_broken_event_get_implicit")]
    pub fn get_implicit(&self) -> bool {
        unsafe {
            from_glib(ffi::gdk_grab_broken_event_get_implicit(
                self.to_glib_none().0,
            ))
        }
    }
}

define_event! {
    KeyEvent,
    ffi::GdkKeyEvent,
    ffi::gdk_key_event_get_type
}

impl KeyEvent {
    #[doc(alias = "gdk_key_event_get_consumed_modifiers")]
    pub fn get_consumed_modifiers(&self) -> ModifierType {
        unsafe {
            from_glib(ffi::gdk_key_event_get_consumed_modifiers(
                self.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "gdk_key_event_get_keycode")]
    pub fn get_keycode(&self) -> u32 {
        unsafe { ffi::gdk_key_event_get_keycode(self.to_glib_none().0) }
    }
    #[doc(alias = "gdk_key_event_get_keyval")]
    pub fn get_keyval(&self) -> Key {
        unsafe { ffi::gdk_key_event_get_keyval(self.to_glib_none().0).into() }
    }

    #[doc(alias = "gdk_key_event_get_layout")]
    pub fn get_layout(&self) -> u32 {
        unsafe { ffi::gdk_key_event_get_layout(self.to_glib_none().0) }
    }

    #[doc(alias = "gdk_key_event_get_level")]
    pub fn get_level(&self) -> u32 {
        unsafe { ffi::gdk_key_event_get_level(self.to_glib_none().0) }
    }

    #[doc(alias = "gdk_key_event_get_match")]
    pub fn get_match(&self) -> Option<(Key, ModifierType)> {
        unsafe {
            let mut keyval = mem::MaybeUninit::uninit();
            let mut modifiers = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gdk_key_event_get_match(
                self.to_glib_none().0,
                keyval.as_mut_ptr(),
                modifiers.as_mut_ptr(),
            ));
            if ret {
                let keyval: Key = keyval.assume_init().into();
                let modifiers = modifiers.assume_init();
                Some((keyval, from_glib(modifiers)))
            } else {
                None
            }
        }
    }

    #[doc(alias = "gdk_key_event_is_modifier")]
    pub fn is_modifier(&self) -> bool {
        unsafe { from_glib(ffi::gdk_key_event_is_modifier(self.to_glib_none().0)) }
    }

    #[doc(alias = "gdk_key_event_matches")]
    pub fn matches(&self, keyval: Key, modifiers: ModifierType) -> KeyMatch {
        unsafe {
            from_glib(ffi::gdk_key_event_matches(
                self.to_glib_none().0,
                keyval.to_glib(),
                modifiers.to_glib(),
            ))
        }
    }
}

define_event! {
    MotionEvent,
    ffi::GdkMotionEvent,
    ffi::gdk_motion_event_get_type
}

define_event! {
    PadEvent,
    ffi::GdkPadEvent,
    ffi::gdk_pad_event_get_type
}

impl PadEvent {
    #[doc(alias = "gdk_pad_event_get_axis_value")]
    pub fn get_axis_value(&self) -> (u32, f64) {
        unsafe {
            let mut index = mem::MaybeUninit::uninit();
            let mut value = mem::MaybeUninit::uninit();
            ffi::gdk_pad_event_get_axis_value(
                self.to_glib_none().0,
                index.as_mut_ptr(),
                value.as_mut_ptr(),
            );
            let index = index.assume_init();
            let value = value.assume_init();
            (index, value)
        }
    }

    #[doc(alias = "gdk_pad_event_get_button")]
    pub fn get_button(&self) -> u32 {
        unsafe { ffi::gdk_pad_event_get_button(self.to_glib_none().0) }
    }

    #[doc(alias = "gdk_pad_event_get_group_mode")]
    pub fn get_group_mode(&self) -> (u32, u32) {
        unsafe {
            let mut group = mem::MaybeUninit::uninit();
            let mut mode = mem::MaybeUninit::uninit();
            ffi::gdk_pad_event_get_group_mode(
                self.to_glib_none().0,
                group.as_mut_ptr(),
                mode.as_mut_ptr(),
            );
            let group = group.assume_init();
            let mode = mode.assume_init();
            (group, mode)
        }
    }
}

define_event! {
    ProximityEvent,
    ffi::GdkProximityEvent,
    ffi::gdk_proximity_event_get_type
}

define_event! {
    ScrollEvent,
    ffi::GdkScrollEvent,
    ffi::gdk_scroll_event_get_type
}

impl ScrollEvent {
    #[doc(alias = "gdk_scroll_event_get_deltas")]
    pub fn get_deltas(&self) -> (f64, f64) {
        unsafe {
            let mut delta_x = mem::MaybeUninit::uninit();
            let mut delta_y = mem::MaybeUninit::uninit();
            ffi::gdk_scroll_event_get_deltas(
                self.to_glib_none().0,
                delta_x.as_mut_ptr(),
                delta_y.as_mut_ptr(),
            );
            let delta_x = delta_x.assume_init();
            let delta_y = delta_y.assume_init();
            (delta_x, delta_y)
        }
    }

    #[doc(alias = "gdk_scroll_event_get_direction")]
    pub fn get_direction(&self) -> ScrollDirection {
        unsafe { from_glib(ffi::gdk_scroll_event_get_direction(self.to_glib_none().0)) }
    }

    #[doc(alias = "gdk_scroll_event_is_stop")]
    pub fn is_stop(&self) -> bool {
        unsafe { from_glib(ffi::gdk_scroll_event_is_stop(self.to_glib_none().0)) }
    }
}

define_event! {
    TouchEvent,
    ffi::GdkTouchEvent,
    ffi::gdk_touch_event_get_type
}

impl TouchEvent {
    #[doc(alias = "gdk_touch_event_get_emulating_pointer")]
    pub fn get_emulating_pointer(&self) -> bool {
        unsafe {
            from_glib(ffi::gdk_touch_event_get_emulating_pointer(
                self.to_glib_none().0,
            ))
        }
    }
}

define_event! {
    TouchpadEvent,
    ffi::GdkTouchpadEvent,
    ffi::gdk_touchpad_event_get_type
}

impl TouchpadEvent {
    #[doc(alias = "gdk_touchpad_event_get_deltas")]
    pub fn get_deltas(&self) -> (f64, f64) {
        unsafe {
            let mut dx = mem::MaybeUninit::uninit();
            let mut dy = mem::MaybeUninit::uninit();
            ffi::gdk_touchpad_event_get_deltas(
                self.to_glib_none().0,
                dx.as_mut_ptr(),
                dy.as_mut_ptr(),
            );
            let dx = dx.assume_init();
            let dy = dy.assume_init();
            (dx, dy)
        }
    }

    #[doc(alias = "gdk_touchpad_event_get_gesture_phase")]
    pub fn get_gesture_phase(&self) -> TouchpadGesturePhase {
        unsafe {
            from_glib(ffi::gdk_touchpad_event_get_gesture_phase(
                self.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "gdk_touchpad_event_get_n_fingers")]
    pub fn get_n_fingers(&self) -> u32 {
        unsafe { ffi::gdk_touchpad_event_get_n_fingers(self.to_glib_none().0) }
    }

    #[doc(alias = "gdk_touchpad_event_get_pinch_angle_delta")]
    pub fn get_pinch_angle_delta(&self) -> f64 {
        unsafe { ffi::gdk_touchpad_event_get_pinch_angle_delta(self.to_glib_none().0) }
    }

    #[doc(alias = "gdk_touchpad_event_get_pinch_scale")]
    pub fn get_pinch_scale(&self) -> f64 {
        unsafe { ffi::gdk_touchpad_event_get_pinch_scale(self.to_glib_none().0) }
    }
}
