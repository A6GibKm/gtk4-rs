// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use BlendMode;
use RenderNode;
use RenderNodeType;
use RoundedRect;
use cairo;
use gdk;
use glib::GString;
use glib::object::IsA;
use glib::translate::*;
use graphene;
use pango;

use std::convert::{TryFrom, TryInto};
use std::fmt;
use std::ops::Deref;

// RenderNode subtypes

macro_rules! convert {
    ($source: ident => $dest: ident = $( $variant: ident )|+ $( ($intermediate: ident) )*) => {
        impl TryFrom<$source> for $dest {
            type Error = $source;

            fn try_from(value: $source) -> Result<Self, $source> {
                if $( value.get_node_type() == RenderNodeType::$variant )||+ {
                    $(
                        let value = $intermediate(value);
                    )*
                    Ok($dest(value))
                }
                else {
                    Err(value)
                }
            }
        }
    };
}

macro_rules! subtype(
    ($subtype: ident $( = $variant: ident)*) => (

        #[derive(Debug, Clone)]
        pub struct $subtype(RenderNode);

        impl Deref for $subtype {
            type Target = RenderNode;

            fn deref(&self) -> &RenderNode {
                &self.0
            }
        }

        impl fmt::Display for $subtype {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                write!(f, stringify!($subtype))
            }
        }

        $(
            convert!(RenderNode => $subtype = $variant);
        )*
    );
);

subtype!(BlendNode = BlendNode);
subtype!(BlurNode = BlurNode);
subtype!(BorderNode = BorderNode);
subtype!(CairoNode = CairoNode);
subtype!(ClipNode = ClipNode);
subtype!(ColorMatrixNode = ColorMatrixNode);
subtype!(ColorNode = ColorNode);
subtype!(ContainerNode = ContainerNode);
subtype!(CrossFadeNode = CrossFadeNode);
subtype!(DebugNode = DebugNode);
subtype!(InsetShadowNode = InsetShadowNode);
subtype!(LinearGradientNode = LinearGradientNode);
subtype!(OpacityNode = OpacityNode);
subtype!(OutsetShadowNode = OutsetShadowNode);
subtype!(RepeatNode = RepeatNode);
subtype!(RoundedClipNode = RoundedClipNode);
subtype!(TextNode = TextNode);
subtype!(TextureNode = TextureNode);

// TODO: cairo_node_peek_surface()
// TODO: container_node_new()
// TODO: linear_gradient_node_new()
// TODO: linear_gradient_node_peek_color_stops()
// TODO: repeating_linear_gradient_node_new()
// TODO: text_node_peek_glyphs()

impl BlendNode {
    pub fn get_blend_mode(self: &BlendNode) -> BlendMode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib(gsk_sys::gsk_blend_node_get_blend_mode(self.to_glib_none().0))
        }
    }

    pub fn get_bottom_child(self: &BlendNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(gsk_sys::gsk_blend_node_get_bottom_child(self.to_glib_none().0))
        }
    }

    pub fn get_top_child(self: &BlendNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(gsk_sys::gsk_blend_node_get_top_child(self.to_glib_none().0))
        }
    }

    pub fn new(bottom: &RenderNode, top: &RenderNode, blend_mode: BlendMode) -> BlendNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_blend_node_new(bottom.to_glib_none().0, top.to_glib_none().0, blend_mode.to_glib()))
        };
        node.try_into().unwrap()
    }
}

impl BlurNode {
    pub fn get_child(self: &BlurNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(gsk_sys::gsk_blur_node_get_child(self.to_glib_none().0))
        }
    }

    pub fn get_radius(self: &BlurNode) -> f64 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_blur_node_get_radius(self.to_glib_none().0)
        }
    }

    pub fn new(child: &RenderNode, radius: f64) -> BlurNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_blur_node_new(child.to_glib_none().0, radius))
        };
        node.try_into().unwrap()
    }
}

impl BorderNode {
    pub fn new(outline: &RoundedRect, border_width: &[f32; 4], border_color: &[gdk::RGBA; 4]) -> BorderNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_border_node_new(outline.to_glib_none().0, border_width.to_glib_none().0 as *const _, border_color.as_ptr() as *const _))
        };
        node.try_into().unwrap()
    }

    pub fn peek_colors(self: &BorderNode) -> gdk::RGBA {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_border_node_peek_colors(self.to_glib_none().0))
        }
    }

    pub fn peek_outline(self: &BorderNode) -> RoundedRect {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_border_node_peek_outline(self.to_glib_none().0))
        }
    }

    pub fn peek_widths(self: &BorderNode) -> [f32; 4] {
        assert_initialized_main_thread!();
        unsafe {
            let widths = gsk_sys::gsk_border_node_peek_widths(self.to_glib_none().0);
            [*widths, *widths.add(1), *widths.add(2), *widths.add(3)]
        }
    }
}

impl CairoNode {
    pub fn get_draw_context(self: &CairoNode) -> cairo::Context {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(gsk_sys::gsk_cairo_node_get_draw_context(self.to_glib_none().0))
        }
    }

    pub fn new(bounds: &graphene::Rect) -> CairoNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_cairo_node_new(bounds.to_glib_none().0))
        };
        node.try_into().unwrap()
    }
}

impl ClipNode {
    pub fn get_child(self: &ClipNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_clip_node_get_child(self.to_glib_none().0))
        }
    }

    pub fn new(child: &RenderNode, clip: &graphene::Rect) -> ClipNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_clip_node_new(child.to_glib_none().0, clip.to_glib_none().0))
        };
        node.try_into().unwrap()
    }

    pub fn peek_clip(self: &ClipNode) -> graphene::Rect {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_clip_node_peek_clip(self.to_glib_none().0))
        }
    }
}

impl ColorMatrixNode {
    pub fn get_child(self: &ColorMatrixNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_color_matrix_node_get_child(self.to_glib_none().0))
        }
    }

    pub fn new(child: &RenderNode, color_matrix: &graphene::Matrix, color_offset: &graphene::Vec4) -> ColorMatrixNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_color_matrix_node_new(child.to_glib_none().0, color_matrix.to_glib_none().0, color_offset.to_glib_none().0))
        };
        node.try_into().unwrap()
    }

    pub fn peek_color_matrix(self: &ColorMatrixNode) -> graphene::Matrix {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_color_matrix_node_peek_color_matrix(self.to_glib_none().0))
        }
    }

    pub fn peek_color_offset(self: &ColorMatrixNode) -> graphene::Vec4 {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_color_matrix_node_peek_color_offset(self.to_glib_none().0))
        }
    }
}

impl ColorNode {
    pub fn new(rgba: &gdk::RGBA, bounds: &graphene::Rect) -> ColorNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_color_node_new(rgba.to_glib_none().0, bounds.to_glib_none().0))
        };
        node.try_into().unwrap()
    }

    pub fn peek_color(self: &ColorNode) -> gdk::RGBA {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_color_node_peek_color(self.to_glib_none().0))
        }
    }
}

impl ContainerNode {
    pub fn get_child(node: &RenderNode, idx: u32) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(gsk_sys::gsk_container_node_get_child(node.to_glib_none().0, idx))
        }
    }

    pub fn get_n_children(self: &ContainerNode) -> u32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_container_node_get_n_children(self.to_glib_none().0)
        }
    }
}

impl CrossFadeNode {
    pub fn get_end_child(self: &CrossFadeNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(gsk_sys::gsk_cross_fade_node_get_end_child(self.to_glib_none().0))
        }
    }

    pub fn get_progress(self: &CrossFadeNode) -> f64 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_cross_fade_node_get_progress(self.to_glib_none().0)
        }
    }

    pub fn get_start_child(self: &CrossFadeNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(gsk_sys::gsk_cross_fade_node_get_start_child(self.to_glib_none().0))
        }
    }

    pub fn new(start: &RenderNode, end: &RenderNode, progress: f64) -> CrossFadeNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_cross_fade_node_new(start.to_glib_none().0, end.to_glib_none().0, progress))
        };
        node.try_into().unwrap()
    }
}

impl DebugNode {
    pub fn get_child(self: &DebugNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_debug_node_get_child(self.to_glib_none().0))
        }
    }

    pub fn get_message(self: &DebugNode) -> GString {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_debug_node_get_message(self.to_glib_none().0))
        }
    }

    pub fn new(child: &RenderNode, message: &str) -> DebugNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_debug_node_new(child.to_glib_none().0, message.to_glib_full()))
        };
        node.try_into().unwrap()
    }
}

impl InsetShadowNode {
    pub fn get_blur_radius(self: &InsetShadowNode) -> f32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_inset_shadow_node_get_blur_radius(self.to_glib_none().0)
        }
    }

    pub fn get_dx(self: &InsetShadowNode) -> f32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_inset_shadow_node_get_dx(self.to_glib_none().0)
        }
    }

    pub fn get_dy(self: &InsetShadowNode) -> f32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_inset_shadow_node_get_dy(self.to_glib_none().0)
        }
    }

    pub fn get_spread(self: &InsetShadowNode) -> f32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_inset_shadow_node_get_spread(self.to_glib_none().0)
        }
    }

    pub fn new(outline: &RoundedRect, color: &gdk::RGBA, dx: f32, dy: f32, spread: f32, blur_radius: f32) -> InsetShadowNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_inset_shadow_node_new(outline.to_glib_none().0, color.to_glib_none().0, dx, dy, spread, blur_radius))
        };
        node.try_into().unwrap()
    }

    pub fn peek_color(self: &InsetShadowNode) -> gdk::RGBA {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_inset_shadow_node_peek_color(self.to_glib_none().0))
        }
    }

    pub fn peek_outline(self: &InsetShadowNode) -> RoundedRect {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_inset_shadow_node_peek_outline(self.to_glib_none().0))
        }
    }
}

impl LinearGradientNode {
    pub fn get_n_color_stops(self: &LinearGradientNode) -> usize {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_linear_gradient_node_get_n_color_stops(self.to_glib_none().0)
        }
    }

    pub fn peek_end(self: &LinearGradientNode) -> graphene::Point {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_linear_gradient_node_peek_end(self.to_glib_none().0))
        }
    }

    pub fn peek_start(self: &LinearGradientNode) -> graphene::Point {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_linear_gradient_node_peek_start(self.to_glib_none().0))
        }
    }
}

impl OpacityNode {
    pub fn get_child(self: &OpacityNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_opacity_node_get_child(self.to_glib_none().0))
        }
    }

    pub fn get_opacity(self: &OpacityNode) -> f64 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_opacity_node_get_opacity(self.to_glib_none().0)
        }
    }

    pub fn new(child: &RenderNode, opacity: f64) -> OpacityNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_opacity_node_new(child.to_glib_none().0, opacity))
        };
        node.try_into().unwrap()
    }
}

impl OutsetShadowNode {
    pub fn get_blur_radius(self: &OutsetShadowNode) -> f32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_outset_shadow_node_get_blur_radius(self.to_glib_none().0)
        }
    }

    pub fn get_dx(self: &OutsetShadowNode) -> f32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_outset_shadow_node_get_dx(self.to_glib_none().0)
        }
    }

    pub fn get_dy(self: &OutsetShadowNode) -> f32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_outset_shadow_node_get_dy(self.to_glib_none().0)
        }
    }

    pub fn get_spread(self: &OutsetShadowNode) -> f32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_outset_shadow_node_get_spread(self.to_glib_none().0)
        }
    }

    pub fn new(outline: &RoundedRect, color: &gdk::RGBA, dx: f32, dy: f32, spread: f32, blur_radius: f32) -> OutsetShadowNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_outset_shadow_node_new(outline.to_glib_none().0, color.to_glib_none().0, dx, dy, spread, blur_radius))
        };
        node.try_into().unwrap()
    }

    pub fn peek_color(self: &OutsetShadowNode) -> gdk::RGBA {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_outset_shadow_node_peek_color(self.to_glib_none().0))
        }
    }

    pub fn peek_outline(self: &OutsetShadowNode) -> RoundedRect {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_outset_shadow_node_peek_outline(self.to_glib_none().0))
        }
    }
}

impl RepeatNode {
    pub fn get_child(self: &RepeatNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(gsk_sys::gsk_repeat_node_get_child(self.to_glib_none().0))
        }
    }

    pub fn new(bounds: &graphene::Rect, child: &RenderNode, child_bounds: Option<&graphene::Rect>) -> RepeatNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_repeat_node_new(bounds.to_glib_none().0, child.to_glib_none().0, child_bounds.to_glib_none().0))
        };
        node.try_into().unwrap()
    }

    pub fn peek_child_bounds(self: &RepeatNode) -> graphene::Rect {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_repeat_node_peek_child_bounds(self.to_glib_none().0))
        }
    }
}

impl RoundedClipNode {
    pub fn get_child(self: &RoundedClipNode) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_rounded_clip_node_get_child(self.to_glib_none().0))
        }
    }

    pub fn new(child: &RenderNode, clip: &RoundedRect) -> RoundedClipNode {
        assert_initialized_main_thread!();
        let node: RenderNode = unsafe {
            from_glib_full(gsk_sys::gsk_rounded_clip_node_new(child.to_glib_none().0, clip.to_glib_none().0))
        };
        node.try_into().unwrap()
    }

    pub fn peek_clip(self: &RoundedClipNode) -> RoundedRect {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_rounded_clip_node_peek_clip(self.to_glib_none().0))
        }
    }
}

impl TextNode {
    pub fn get_num_glyphs(self: &TextNode) -> u32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_text_node_get_num_glyphs(self.to_glib_none().0)
        }
    }

    pub fn get_x(self: &TextNode) -> f32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_text_node_get_x(self.to_glib_none().0)
        }
    }

    pub fn get_y(self: &TextNode) -> f32 {
        assert_initialized_main_thread!();
        unsafe {
            gsk_sys::gsk_text_node_get_y(self.to_glib_none().0)
        }
    }

    pub fn new<P: IsA<pango::Font>>(font: &P, glyphs: &mut pango::GlyphString, color: &gdk::RGBA, x: f32, y: f32) -> Option<RenderNode> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(gsk_sys::gsk_text_node_new(font.as_ref().to_glib_none().0, glyphs.to_glib_none_mut().0, color.to_glib_none().0, x, y))
        }
    }

    pub fn peek_color(self: &TextNode) -> gdk::RGBA {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_text_node_peek_color(self.to_glib_none().0))
        }
    }

    pub fn peek_font(self: &TextNode) -> pango::Font {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_text_node_peek_font(self.to_glib_none().0))
        }
    }
}

impl TextureNode {
    pub fn get_texture(self: &TextureNode) -> gdk::Texture {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(gsk_sys::gsk_texture_node_get_texture(self.to_glib_none().0))
        }
    }

    pub fn new<P: IsA<gdk::Texture>>(texture: &P, bounds: &graphene::Rect) -> RenderNode {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(gsk_sys::gsk_texture_node_new(texture.as_ref().to_glib_none().0, bounds.to_glib_none().0))
        }
    }
}
