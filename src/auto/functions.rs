// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use Atom;
use Display;
use Event;
use ffi;
use glib::GString;
use glib::translate::*;
use std::mem;
use std::ptr;


//pub fn cairo_draw_from_gl<P: IsA<Surface>>(cr: /*Ignored*/&cairo::Context, surface: &P, source: i32, source_type: i32, buffer_scale: i32, x: i32, y: i32, width: i32, height: i32) {
//    unsafe { TODO: call ffi::gdk_cairo_draw_from_gl() }
//}

//pub fn cairo_get_clip_rectangle(cr: /*Ignored*/&cairo::Context) -> Option<Rectangle> {
//    unsafe { TODO: call ffi::gdk_cairo_get_clip_rectangle() }
//}

//pub fn cairo_rectangle(cr: /*Ignored*/&cairo::Context, rectangle: &Rectangle) {
//    unsafe { TODO: call ffi::gdk_cairo_rectangle() }
//}

//pub fn cairo_region(cr: /*Ignored*/&cairo::Context, region: /*Ignored*/&cairo::Region) {
//    unsafe { TODO: call ffi::gdk_cairo_region() }
//}

//pub fn cairo_region_create_from_surface(surface: /*Ignored*/&cairo::Surface) -> /*Ignored*/Option<cairo::Region> {
//    unsafe { TODO: call ffi::gdk_cairo_region_create_from_surface() }
//}

//pub fn cairo_set_source_pixbuf(cr: /*Ignored*/&cairo::Context, pixbuf: /*Ignored*/&gdk_pixbuf::Pixbuf, pixbuf_x: f64, pixbuf_y: f64) {
//    unsafe { TODO: call ffi::gdk_cairo_set_source_pixbuf() }
//}

//pub fn cairo_set_source_rgba(cr: /*Ignored*/&cairo::Context, rgba: &RGBA) {
//    unsafe { TODO: call ffi::gdk_cairo_set_source_rgba() }
//}

//pub fn cairo_surface_upload_to_gl(surface: /*Ignored*/&cairo::Surface, target: i32, width: i32, height: i32, context: Option<&GLContext>) {
//    unsafe { TODO: call ffi::gdk_cairo_surface_upload_to_gl() }
//}

//pub fn content_deserialize_async<P: FnOnce(Result<(), Error>) + Send + 'static>(stream: /*Ignored*/&gio::InputStream, mime_type: &str, type_: glib::types::Type, io_priority: i32, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
//    unsafe { TODO: call ffi::gdk_content_deserialize_async() }
//}

//#[cfg(feature = "futures")]
//pub fn content_deserialize_async_future(stream: /*Ignored*/&gio::InputStream, mime_type: &str, type_: glib::types::Type, io_priority: i32) -> Box_<futures_core::Future<Item = (), Error = Error>> {
    //use gio::GioFuture;
    //use fragile::Fragile;

    //let stream = stream.clone();
    //let mime_type = String::from(mime_type);
    //GioFuture::new(&(), move |_obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    let send = Fragile::new(send);
    //    content_deserialize_async(
    //        &stream,
    //        &mime_type,
    //        type_,
    //        io_priority,
    //        Some(&cancellable),
    //        move |res| {
    //            let _ = send.into_inner().send(res);
    //        },
    //    );

    //    cancellable
    //})
//}

//pub fn content_register_deserializer<P: Fn(&ContentDeserializer) + Send + Sync + 'static>(mime_type: &str, type_: glib::types::Type, deserialize: P, data: /*Unimplemented*/Option<Fundamental: Pointer>) {
//    unsafe { TODO: call ffi::gdk_content_register_deserializer() }
//}

//pub fn content_register_serializer<P: Fn(&ContentSerializer) + Send + Sync + 'static>(type_: glib::types::Type, mime_type: &str, serialize: P, data: /*Unimplemented*/Option<Fundamental: Pointer>) {
//    unsafe { TODO: call ffi::gdk_content_register_serializer() }
//}

//pub fn content_serialize_async<P: FnOnce(Result<(), Error>) + Send + 'static>(stream: /*Ignored*/&gio::OutputStream, mime_type: &str, value: /*Ignored*/&glib::Value, io_priority: i32, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
//    unsafe { TODO: call ffi::gdk_content_serialize_async() }
//}

//#[cfg(feature = "futures")]
//pub fn content_serialize_async_future(stream: /*Ignored*/&gio::OutputStream, mime_type: &str, value: /*Ignored*/&glib::Value, io_priority: i32) -> Box_<futures_core::Future<Item = (), Error = Error>> {
    //use gio::GioFuture;
    //use fragile::Fragile;

    //let stream = stream.clone();
    //let mime_type = String::from(mime_type);
    //let value = value.clone();
    //GioFuture::new(&(), move |_obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    let send = Fragile::new(send);
    //    content_serialize_async(
    //        &stream,
    //        &mime_type,
    //        &value,
    //        io_priority,
    //        Some(&cancellable),
    //        move |res| {
    //            let _ = send.into_inner().send(res);
    //        },
    //    );

    //    cancellable
    //})
//}

pub fn events_get_angle(event1: &Event, event2: &Event) -> Option<f64> {
    skip_assert_initialized!();
    unsafe {
        let mut angle = mem::uninitialized();
        let ret = from_glib(ffi::gdk_events_get_angle(event1.to_glib_none().0, event2.to_glib_none().0, &mut angle));
        if ret { Some(angle) } else { None }
    }
}

pub fn events_get_center(event1: &Event, event2: &Event) -> Option<(f64, f64)> {
    skip_assert_initialized!();
    unsafe {
        let mut x = mem::uninitialized();
        let mut y = mem::uninitialized();
        let ret = from_glib(ffi::gdk_events_get_center(event1.to_glib_none().0, event2.to_glib_none().0, &mut x, &mut y));
        if ret { Some((x, y)) } else { None }
    }
}

pub fn events_get_distance(event1: &Event, event2: &Event) -> Option<f64> {
    skip_assert_initialized!();
    unsafe {
        let mut distance = mem::uninitialized();
        let ret = from_glib(ffi::gdk_events_get_distance(event1.to_glib_none().0, event2.to_glib_none().0, &mut distance));
        if ret { Some(distance) } else { None }
    }
}

pub fn get_show_events() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gdk_get_show_events())
    }
}

pub fn intern_mime_type(string: &str) -> Option<GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gdk_intern_mime_type(string.to_glib_none().0))
    }
}

pub fn keyval_convert_case(symbol: u32) -> (u32, u32) {
    assert_initialized_main_thread!();
    unsafe {
        let mut lower = mem::uninitialized();
        let mut upper = mem::uninitialized();
        ffi::gdk_keyval_convert_case(symbol, &mut lower, &mut upper);
        (lower, upper)
    }
}

pub fn keyval_from_name(keyval_name: &str) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gdk_keyval_from_name(keyval_name.to_glib_none().0)
    }
}

pub fn keyval_is_lower(keyval: u32) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gdk_keyval_is_lower(keyval))
    }
}

pub fn keyval_is_upper(keyval: u32) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gdk_keyval_is_upper(keyval))
    }
}

pub fn keyval_name(keyval: u32) -> Option<GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gdk_keyval_name(keyval))
    }
}

pub fn keyval_to_lower(keyval: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gdk_keyval_to_lower(keyval)
    }
}

pub fn keyval_to_unicode(keyval: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gdk_keyval_to_unicode(keyval)
    }
}

pub fn keyval_to_upper(keyval: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gdk_keyval_to_upper(keyval)
    }
}

//pub fn pango_layout_get_clip_region(layout: /*Ignored*/&pango::Layout, x_origin: i32, y_origin: i32, index_ranges: i32, n_ranges: i32) -> /*Ignored*/Option<cairo::Region> {
//    unsafe { TODO: call ffi::gdk_pango_layout_get_clip_region() }
//}

//pub fn pango_layout_line_get_clip_region(line: /*Ignored*/&pango::LayoutLine, x_origin: i32, y_origin: i32, index_ranges: &[i32], n_ranges: i32) -> /*Ignored*/Option<cairo::Region> {
//    unsafe { TODO: call ffi::gdk_pango_layout_line_get_clip_region() }
//}

//pub fn pixbuf_get_from_surface(surface: /*Ignored*/&cairo::Surface, src_x: i32, src_y: i32, width: i32, height: i32) -> /*Ignored*/Option<gdk_pixbuf::Pixbuf> {
//    unsafe { TODO: call ffi::gdk_pixbuf_get_from_surface() }
//}

pub fn set_allowed_backends(backends: &str) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gdk_set_allowed_backends(backends.to_glib_none().0);
    }
}

pub fn set_show_events(show_events: bool) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gdk_set_show_events(show_events.to_glib());
    }
}

pub fn text_property_to_utf8_list_for_display(display: &Display, encoding: &Atom, format: i32, text: &[u8]) -> (i32, Vec<GString>) {
    skip_assert_initialized!();
    let length = text.len() as i32;
    unsafe {
        let mut list = ptr::null_mut();
        let ret = ffi::gdk_text_property_to_utf8_list_for_display(display.to_glib_none().0, encoding.to_glib_none().0, format, text.to_glib_none().0, length, &mut list);
        (ret, FromGlibPtrContainer::from_glib_full(list))
    }
}

pub fn unicode_to_keyval(wc: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gdk_unicode_to_keyval(wc)
    }
}

pub fn utf8_to_string_target(str: &str) -> Option<GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gdk_utf8_to_string_target(str.to_glib_none().0))
    }
}
