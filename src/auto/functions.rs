// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use Atom;
use Display;
use Error;
use Event;
use GLContext;
use RGBA;
use Rectangle;
use Surface;
use cairo;
#[cfg(feature = "futures")]
use futures::future;
use gdk_pixbuf;
use gdk_sys;
use gio;
use gio_sys;
use glib;
use glib::GString;
use glib::object::IsA;
use glib::translate::*;
use glib_sys;
use gobject_sys;
#[cfg(feature = "futures")]
use std::boxed::Box as Box_;
use std::mem;
use std::ptr;


pub fn cairo_draw_from_gl<P: IsA<Surface>>(cr: &cairo::Context, surface: &P, source: i32, source_type: i32, buffer_scale: i32, x: i32, y: i32, width: i32, height: i32) {
    skip_assert_initialized!();
    unsafe {
        gdk_sys::gdk_cairo_draw_from_gl(mut_override(cr.to_glib_none().0), surface.as_ref().to_glib_none().0, source, source_type, buffer_scale, x, y, width, height);
    }
}

pub fn cairo_get_clip_rectangle(cr: &cairo::Context) -> Option<Rectangle> {
    assert_initialized_main_thread!();
    unsafe {
        let mut rect = Rectangle::uninitialized();
        let ret = from_glib(gdk_sys::gdk_cairo_get_clip_rectangle(mut_override(cr.to_glib_none().0), rect.to_glib_none_mut().0));
        if ret { Some(rect) } else { None }
    }
}

pub fn cairo_rectangle(cr: &cairo::Context, rectangle: &Rectangle) {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_cairo_rectangle(mut_override(cr.to_glib_none().0), rectangle.to_glib_none().0);
    }
}

pub fn cairo_region(cr: &cairo::Context, region: &cairo::Region) {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_cairo_region(mut_override(cr.to_glib_none().0), region.to_glib_none().0);
    }
}

pub fn cairo_region_create_from_surface(surface: &cairo::Surface) -> Option<cairo::Region> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(gdk_sys::gdk_cairo_region_create_from_surface(mut_override(surface.to_glib_none().0)))
    }
}

pub fn cairo_set_source_pixbuf(cr: &cairo::Context, pixbuf: &gdk_pixbuf::Pixbuf, pixbuf_x: f64, pixbuf_y: f64) {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_cairo_set_source_pixbuf(mut_override(cr.to_glib_none().0), pixbuf.to_glib_none().0, pixbuf_x, pixbuf_y);
    }
}

pub fn cairo_set_source_rgba(cr: &cairo::Context, rgba: &RGBA) {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_cairo_set_source_rgba(mut_override(cr.to_glib_none().0), rgba.to_glib_none().0);
    }
}

pub fn cairo_surface_upload_to_gl(surface: &cairo::Surface, target: i32, width: i32, height: i32, context: Option<&GLContext>) {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_cairo_surface_upload_to_gl(mut_override(surface.to_glib_none().0), target, width, height, context.to_glib_none().0);
    }
}

//pub fn content_deserialize_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), Error>) + Send + 'static>(stream: /*Ignored*/&gio::InputStream, mime_type: &str, type_: glib::types::Type, io_priority: i32, cancellable: Option<&P>, callback: Q) {
//    unsafe { TODO: call gdk_sys:gdk_content_deserialize_async() }
//}

//#[cfg(feature = "futures")]
//pub fn content_deserialize_async_future(stream: /*Ignored*/&gio::InputStream, mime_type: &str, type_: glib::types::Type, io_priority: i32) -> Box_<dyn future::Future<Output = Result<(), Error>> + std::marker::Unpin> {
    //use gio::GioFuture;
    //use fragile::Fragile;

    //let stream = stream.clone();
    //let mime_type = String::from(mime_type);
    //GioFuture::new(&(), move |_obj, send| {
    //    let cancellable = gio::Cancellable::new();
    //    let send = Fragile::new(send);
    //    content_deserialize_async(
    //        &stream,
    //        &mime_type,
    //        type_,
    //        io_priority,
    //        Some(&cancellable),
    //        move |res| {
    //            let _ = send.into_inner().send(res);
    //        },
    //    );

    //    cancellable
    //})
//}

//pub fn content_register_deserializer<P: Fn(&ContentDeserializer) + Send + Sync + 'static>(mime_type: &str, type_: glib::types::Type, deserialize: P, data: /*Unimplemented*/Option<Fundamental: Pointer>) {
//    unsafe { TODO: call gdk_sys:gdk_content_register_deserializer() }
//}

//pub fn content_register_serializer<P: Fn(&ContentSerializer) + Send + Sync + 'static>(type_: glib::types::Type, mime_type: &str, serialize: P, data: /*Unimplemented*/Option<Fundamental: Pointer>) {
//    unsafe { TODO: call gdk_sys:gdk_content_register_serializer() }
//}

pub fn content_serialize_async<P: IsA<gio::OutputStream>, Q: IsA<gio::Cancellable>, R: FnOnce(Result<(), Error>) + Send + 'static>(stream: &P, mime_type: &str, value: &glib::Value, io_priority: i32, cancellable: Option<&Q>, callback: R) {
    assert_initialized_main_thread!();
    let user_data: Box<R> = Box::new(callback);
    unsafe extern "C" fn content_serialize_async_trampoline<R: FnOnce(Result<(), Error>) + Send + 'static>(_source_object: *mut gobject_sys::GObject, res: *mut gio_sys::GAsyncResult, user_data: glib_sys::gpointer) {
        let mut error = ptr::null_mut();
        let _ = gdk_sys::gdk_content_serialize_finish(res, &mut error);
        let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
        let callback: Box<R> = Box::from_raw(user_data as *mut _);
        callback(result);
    }
    let callback = content_serialize_async_trampoline::<R>;
    unsafe {
        gdk_sys::gdk_content_serialize_async(stream.as_ref().to_glib_none().0, mime_type.to_glib_none().0, value.to_glib_none().0, io_priority, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box::into_raw(user_data) as *mut _);
    }
}

#[cfg(feature = "futures")]
pub fn content_serialize_async_future<P: IsA<gio::OutputStream> + Clone + 'static>(stream: &P, mime_type: &str, value: &glib::Value, io_priority: i32) -> Box_<dyn future::Future<Output = Result<(), Error>> + std::marker::Unpin> {
    use gio::GioFuture;
    use fragile::Fragile;

    let stream = stream.clone();
    let mime_type = String::from(mime_type);
    let value = value.clone();
    GioFuture::new(&(), move |_obj, send| {
        let cancellable = gio::Cancellable::new();
        let send = Fragile::new(send);
        content_serialize_async(
            &stream,
            &mime_type,
            &value,
            io_priority,
            Some(&cancellable),
            move |res| {
                let _ = send.into_inner().send(res);
            },
        );

        cancellable
    })
}

pub fn events_get_angle(event1: &Event, event2: &Event) -> Option<f64> {
    skip_assert_initialized!();
    unsafe {
        let mut angle = mem::uninitialized();
        let ret = from_glib(gdk_sys::gdk_events_get_angle(event1.to_glib_none().0, event2.to_glib_none().0, &mut angle));
        if ret { Some(angle) } else { None }
    }
}

pub fn events_get_center(event1: &Event, event2: &Event) -> Option<(f64, f64)> {
    skip_assert_initialized!();
    unsafe {
        let mut x = mem::uninitialized();
        let mut y = mem::uninitialized();
        let ret = from_glib(gdk_sys::gdk_events_get_center(event1.to_glib_none().0, event2.to_glib_none().0, &mut x, &mut y));
        if ret { Some((x, y)) } else { None }
    }
}

pub fn events_get_distance(event1: &Event, event2: &Event) -> Option<f64> {
    skip_assert_initialized!();
    unsafe {
        let mut distance = mem::uninitialized();
        let ret = from_glib(gdk_sys::gdk_events_get_distance(event1.to_glib_none().0, event2.to_glib_none().0, &mut distance));
        if ret { Some(distance) } else { None }
    }
}

pub fn get_show_events() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(gdk_sys::gdk_get_show_events())
    }
}

pub fn intern_mime_type(string: &str) -> Option<GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(gdk_sys::gdk_intern_mime_type(string.to_glib_none().0))
    }
}

pub fn keyval_convert_case(symbol: u32) -> (u32, u32) {
    assert_initialized_main_thread!();
    unsafe {
        let mut lower = mem::uninitialized();
        let mut upper = mem::uninitialized();
        gdk_sys::gdk_keyval_convert_case(symbol, &mut lower, &mut upper);
        (lower, upper)
    }
}

pub fn keyval_from_name(keyval_name: &str) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_keyval_from_name(keyval_name.to_glib_none().0)
    }
}

pub fn keyval_is_lower(keyval: u32) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(gdk_sys::gdk_keyval_is_lower(keyval))
    }
}

pub fn keyval_is_upper(keyval: u32) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(gdk_sys::gdk_keyval_is_upper(keyval))
    }
}

pub fn keyval_name(keyval: u32) -> Option<GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(gdk_sys::gdk_keyval_name(keyval))
    }
}

pub fn keyval_to_lower(keyval: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_keyval_to_lower(keyval)
    }
}

pub fn keyval_to_unicode(keyval: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_keyval_to_unicode(keyval)
    }
}

pub fn keyval_to_upper(keyval: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_keyval_to_upper(keyval)
    }
}

pub fn pixbuf_get_from_surface(surface: &cairo::Surface, src_x: i32, src_y: i32, width: i32, height: i32) -> Option<gdk_pixbuf::Pixbuf> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(gdk_sys::gdk_pixbuf_get_from_surface(mut_override(surface.to_glib_none().0), src_x, src_y, width, height))
    }
}

pub fn set_allowed_backends(backends: &str) {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_set_allowed_backends(backends.to_glib_none().0);
    }
}

pub fn set_show_events(show_events: bool) {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_set_show_events(show_events.to_glib());
    }
}

pub fn text_property_to_utf8_list_for_display(display: &Display, encoding: &Atom, format: i32, text: &[u8]) -> (i32, Vec<GString>) {
    skip_assert_initialized!();
    let length = text.len() as i32;
    unsafe {
        let mut list = ptr::null_mut();
        let ret = gdk_sys::gdk_text_property_to_utf8_list_for_display(display.to_glib_none().0, encoding.to_glib_none().0, format, text.to_glib_none().0, length, &mut list);
        (ret, FromGlibPtrContainer::from_glib_full(list))
    }
}

pub fn unicode_to_keyval(wc: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        gdk_sys::gdk_unicode_to_keyval(wc)
    }
}

pub fn utf8_to_string_target(str: &str) -> Option<GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(gdk_sys::gdk_utf8_to_string_target(str.to_glib_none().0))
    }
}
