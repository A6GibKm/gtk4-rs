// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use gsk_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BlendMode {
    Default,
    Multiply,
    Screen,
    Overlay,
    Darken,
    Lighten,
    ColorDodge,
    ColorBurn,
    HardLight,
    SoftLight,
    Difference,
    Exclusion,
    Color,
    Hue,
    Saturation,
    Luminosity,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BlendMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BlendMode::{}",
            match *self {
                BlendMode::Default => "Default",
                BlendMode::Multiply => "Multiply",
                BlendMode::Screen => "Screen",
                BlendMode::Overlay => "Overlay",
                BlendMode::Darken => "Darken",
                BlendMode::Lighten => "Lighten",
                BlendMode::ColorDodge => "ColorDodge",
                BlendMode::ColorBurn => "ColorBurn",
                BlendMode::HardLight => "HardLight",
                BlendMode::SoftLight => "SoftLight",
                BlendMode::Difference => "Difference",
                BlendMode::Exclusion => "Exclusion",
                BlendMode::Color => "Color",
                BlendMode::Hue => "Hue",
                BlendMode::Saturation => "Saturation",
                BlendMode::Luminosity => "Luminosity",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BlendMode {
    type GlibType = gsk_sys::GskBlendMode;

    fn to_glib(&self) -> gsk_sys::GskBlendMode {
        match *self {
            BlendMode::Default => gsk_sys::GSK_BLEND_MODE_DEFAULT,
            BlendMode::Multiply => gsk_sys::GSK_BLEND_MODE_MULTIPLY,
            BlendMode::Screen => gsk_sys::GSK_BLEND_MODE_SCREEN,
            BlendMode::Overlay => gsk_sys::GSK_BLEND_MODE_OVERLAY,
            BlendMode::Darken => gsk_sys::GSK_BLEND_MODE_DARKEN,
            BlendMode::Lighten => gsk_sys::GSK_BLEND_MODE_LIGHTEN,
            BlendMode::ColorDodge => gsk_sys::GSK_BLEND_MODE_COLOR_DODGE,
            BlendMode::ColorBurn => gsk_sys::GSK_BLEND_MODE_COLOR_BURN,
            BlendMode::HardLight => gsk_sys::GSK_BLEND_MODE_HARD_LIGHT,
            BlendMode::SoftLight => gsk_sys::GSK_BLEND_MODE_SOFT_LIGHT,
            BlendMode::Difference => gsk_sys::GSK_BLEND_MODE_DIFFERENCE,
            BlendMode::Exclusion => gsk_sys::GSK_BLEND_MODE_EXCLUSION,
            BlendMode::Color => gsk_sys::GSK_BLEND_MODE_COLOR,
            BlendMode::Hue => gsk_sys::GSK_BLEND_MODE_HUE,
            BlendMode::Saturation => gsk_sys::GSK_BLEND_MODE_SATURATION,
            BlendMode::Luminosity => gsk_sys::GSK_BLEND_MODE_LUMINOSITY,
            BlendMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gsk_sys::GskBlendMode> for BlendMode {
    fn from_glib(value: gsk_sys::GskBlendMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BlendMode::Default,
            1 => BlendMode::Multiply,
            2 => BlendMode::Screen,
            3 => BlendMode::Overlay,
            4 => BlendMode::Darken,
            5 => BlendMode::Lighten,
            6 => BlendMode::ColorDodge,
            7 => BlendMode::ColorBurn,
            8 => BlendMode::HardLight,
            9 => BlendMode::SoftLight,
            10 => BlendMode::Difference,
            11 => BlendMode::Exclusion,
            12 => BlendMode::Color,
            13 => BlendMode::Hue,
            14 => BlendMode::Saturation,
            15 => BlendMode::Luminosity,
            value => BlendMode::__Unknown(value),
        }
    }
}

impl StaticType for BlendMode {
    fn static_type() -> Type {
        unsafe { from_glib(gsk_sys::gsk_blend_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BlendMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BlendMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BlendMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Corner {
    TopLeft,
    TopRight,
    BottomRight,
    BottomLeft,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Corner {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Corner::{}",
            match *self {
                Corner::TopLeft => "TopLeft",
                Corner::TopRight => "TopRight",
                Corner::BottomRight => "BottomRight",
                Corner::BottomLeft => "BottomLeft",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Corner {
    type GlibType = gsk_sys::GskCorner;

    fn to_glib(&self) -> gsk_sys::GskCorner {
        match *self {
            Corner::TopLeft => gsk_sys::GSK_CORNER_TOP_LEFT,
            Corner::TopRight => gsk_sys::GSK_CORNER_TOP_RIGHT,
            Corner::BottomRight => gsk_sys::GSK_CORNER_BOTTOM_RIGHT,
            Corner::BottomLeft => gsk_sys::GSK_CORNER_BOTTOM_LEFT,
            Corner::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gsk_sys::GskCorner> for Corner {
    fn from_glib(value: gsk_sys::GskCorner) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Corner::TopLeft,
            1 => Corner::TopRight,
            2 => Corner::BottomRight,
            3 => Corner::BottomLeft,
            value => Corner::__Unknown(value),
        }
    }
}

impl StaticType for Corner {
    fn static_type() -> Type {
        unsafe { from_glib(gsk_sys::gsk_corner_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Corner {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Corner {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Corner {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RenderNodeType {
    NotARenderNode,
    ContainerNode,
    CairoNode,
    ColorNode,
    LinearGradientNode,
    RepeatingLinearGradientNode,
    BorderNode,
    TextureNode,
    InsetShadowNode,
    OutsetShadowNode,
    TransformNode,
    OpacityNode,
    ColorMatrixNode,
    RepeatNode,
    ClipNode,
    RoundedClipNode,
    ShadowNode,
    BlendNode,
    CrossFadeNode,
    TextNode,
    BlurNode,
    DebugNode,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RenderNodeType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RenderNodeType::{}",
            match *self {
                RenderNodeType::NotARenderNode => "NotARenderNode",
                RenderNodeType::ContainerNode => "ContainerNode",
                RenderNodeType::CairoNode => "CairoNode",
                RenderNodeType::ColorNode => "ColorNode",
                RenderNodeType::LinearGradientNode => "LinearGradientNode",
                RenderNodeType::RepeatingLinearGradientNode => "RepeatingLinearGradientNode",
                RenderNodeType::BorderNode => "BorderNode",
                RenderNodeType::TextureNode => "TextureNode",
                RenderNodeType::InsetShadowNode => "InsetShadowNode",
                RenderNodeType::OutsetShadowNode => "OutsetShadowNode",
                RenderNodeType::TransformNode => "TransformNode",
                RenderNodeType::OpacityNode => "OpacityNode",
                RenderNodeType::ColorMatrixNode => "ColorMatrixNode",
                RenderNodeType::RepeatNode => "RepeatNode",
                RenderNodeType::ClipNode => "ClipNode",
                RenderNodeType::RoundedClipNode => "RoundedClipNode",
                RenderNodeType::ShadowNode => "ShadowNode",
                RenderNodeType::BlendNode => "BlendNode",
                RenderNodeType::CrossFadeNode => "CrossFadeNode",
                RenderNodeType::TextNode => "TextNode",
                RenderNodeType::BlurNode => "BlurNode",
                RenderNodeType::DebugNode => "DebugNode",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RenderNodeType {
    type GlibType = gsk_sys::GskRenderNodeType;

    fn to_glib(&self) -> gsk_sys::GskRenderNodeType {
        match *self {
            RenderNodeType::NotARenderNode => gsk_sys::GSK_NOT_A_RENDER_NODE,
            RenderNodeType::ContainerNode => gsk_sys::GSK_CONTAINER_NODE,
            RenderNodeType::CairoNode => gsk_sys::GSK_CAIRO_NODE,
            RenderNodeType::ColorNode => gsk_sys::GSK_COLOR_NODE,
            RenderNodeType::LinearGradientNode => gsk_sys::GSK_LINEAR_GRADIENT_NODE,
            RenderNodeType::RepeatingLinearGradientNode => {
                gsk_sys::GSK_REPEATING_LINEAR_GRADIENT_NODE
            }
            RenderNodeType::BorderNode => gsk_sys::GSK_BORDER_NODE,
            RenderNodeType::TextureNode => gsk_sys::GSK_TEXTURE_NODE,
            RenderNodeType::InsetShadowNode => gsk_sys::GSK_INSET_SHADOW_NODE,
            RenderNodeType::OutsetShadowNode => gsk_sys::GSK_OUTSET_SHADOW_NODE,
            RenderNodeType::TransformNode => gsk_sys::GSK_TRANSFORM_NODE,
            RenderNodeType::OpacityNode => gsk_sys::GSK_OPACITY_NODE,
            RenderNodeType::ColorMatrixNode => gsk_sys::GSK_COLOR_MATRIX_NODE,
            RenderNodeType::RepeatNode => gsk_sys::GSK_REPEAT_NODE,
            RenderNodeType::ClipNode => gsk_sys::GSK_CLIP_NODE,
            RenderNodeType::RoundedClipNode => gsk_sys::GSK_ROUNDED_CLIP_NODE,
            RenderNodeType::ShadowNode => gsk_sys::GSK_SHADOW_NODE,
            RenderNodeType::BlendNode => gsk_sys::GSK_BLEND_NODE,
            RenderNodeType::CrossFadeNode => gsk_sys::GSK_CROSS_FADE_NODE,
            RenderNodeType::TextNode => gsk_sys::GSK_TEXT_NODE,
            RenderNodeType::BlurNode => gsk_sys::GSK_BLUR_NODE,
            RenderNodeType::DebugNode => gsk_sys::GSK_DEBUG_NODE,
            RenderNodeType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gsk_sys::GskRenderNodeType> for RenderNodeType {
    fn from_glib(value: gsk_sys::GskRenderNodeType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RenderNodeType::NotARenderNode,
            1 => RenderNodeType::ContainerNode,
            2 => RenderNodeType::CairoNode,
            3 => RenderNodeType::ColorNode,
            4 => RenderNodeType::LinearGradientNode,
            5 => RenderNodeType::RepeatingLinearGradientNode,
            6 => RenderNodeType::BorderNode,
            7 => RenderNodeType::TextureNode,
            8 => RenderNodeType::InsetShadowNode,
            9 => RenderNodeType::OutsetShadowNode,
            10 => RenderNodeType::TransformNode,
            11 => RenderNodeType::OpacityNode,
            12 => RenderNodeType::ColorMatrixNode,
            13 => RenderNodeType::RepeatNode,
            14 => RenderNodeType::ClipNode,
            15 => RenderNodeType::RoundedClipNode,
            16 => RenderNodeType::ShadowNode,
            17 => RenderNodeType::BlendNode,
            18 => RenderNodeType::CrossFadeNode,
            19 => RenderNodeType::TextNode,
            20 => RenderNodeType::BlurNode,
            21 => RenderNodeType::DebugNode,
            value => RenderNodeType::__Unknown(value),
        }
    }
}

impl StaticType for RenderNodeType {
    fn static_type() -> Type {
        unsafe { from_glib(gsk_sys::gsk_render_node_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RenderNodeType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RenderNodeType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RenderNodeType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ScalingFilter {
    Linear,
    Nearest,
    Trilinear,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScalingFilter {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScalingFilter::{}",
            match *self {
                ScalingFilter::Linear => "Linear",
                ScalingFilter::Nearest => "Nearest",
                ScalingFilter::Trilinear => "Trilinear",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ScalingFilter {
    type GlibType = gsk_sys::GskScalingFilter;

    fn to_glib(&self) -> gsk_sys::GskScalingFilter {
        match *self {
            ScalingFilter::Linear => gsk_sys::GSK_SCALING_FILTER_LINEAR,
            ScalingFilter::Nearest => gsk_sys::GSK_SCALING_FILTER_NEAREST,
            ScalingFilter::Trilinear => gsk_sys::GSK_SCALING_FILTER_TRILINEAR,
            ScalingFilter::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gsk_sys::GskScalingFilter> for ScalingFilter {
    fn from_glib(value: gsk_sys::GskScalingFilter) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScalingFilter::Linear,
            1 => ScalingFilter::Nearest,
            2 => ScalingFilter::Trilinear,
            value => ScalingFilter::__Unknown(value),
        }
    }
}

impl StaticType for ScalingFilter {
    fn static_type() -> Type {
        unsafe { from_glib(gsk_sys::gsk_scaling_filter_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScalingFilter {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScalingFilter {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScalingFilter {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SerializationError {
    UnsupportedFormat,
    UnsupportedVersion,
    InvalidData,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SerializationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SerializationError::{}",
            match *self {
                SerializationError::UnsupportedFormat => "UnsupportedFormat",
                SerializationError::UnsupportedVersion => "UnsupportedVersion",
                SerializationError::InvalidData => "InvalidData",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SerializationError {
    type GlibType = gsk_sys::GskSerializationError;

    fn to_glib(&self) -> gsk_sys::GskSerializationError {
        match *self {
            SerializationError::UnsupportedFormat => gsk_sys::GSK_SERIALIZATION_UNSUPPORTED_FORMAT,
            SerializationError::UnsupportedVersion => {
                gsk_sys::GSK_SERIALIZATION_UNSUPPORTED_VERSION
            }
            SerializationError::InvalidData => gsk_sys::GSK_SERIALIZATION_INVALID_DATA,
            SerializationError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gsk_sys::GskSerializationError> for SerializationError {
    fn from_glib(value: gsk_sys::GskSerializationError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SerializationError::UnsupportedFormat,
            1 => SerializationError::UnsupportedVersion,
            2 => SerializationError::InvalidData,
            value => SerializationError::__Unknown(value),
        }
    }
}

impl ErrorDomain for SerializationError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(gsk_sys::gsk_serialization_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(SerializationError::UnsupportedFormat),
            1 => Some(SerializationError::UnsupportedVersion),
            2 => Some(SerializationError::InvalidData),
            value => Some(SerializationError::__Unknown(value)),
        }
    }
}

impl StaticType for SerializationError {
    fn static_type() -> Type {
        unsafe { from_glib(gsk_sys::gsk_serialization_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SerializationError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SerializationError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SerializationError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TransformCategory {
    Unknown,
    Any,
    _3d,
    _2d,
    _2dAffine,
    _2dTranslate,
    Identity,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TransformCategory {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TransformCategory::{}",
            match *self {
                TransformCategory::Unknown => "Unknown",
                TransformCategory::Any => "Any",
                TransformCategory::_3d => "_3d",
                TransformCategory::_2d => "_2d",
                TransformCategory::_2dAffine => "_2dAffine",
                TransformCategory::_2dTranslate => "_2dTranslate",
                TransformCategory::Identity => "Identity",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TransformCategory {
    type GlibType = gsk_sys::GskTransformCategory;

    fn to_glib(&self) -> gsk_sys::GskTransformCategory {
        match *self {
            TransformCategory::Unknown => gsk_sys::GSK_TRANSFORM_CATEGORY_UNKNOWN,
            TransformCategory::Any => gsk_sys::GSK_TRANSFORM_CATEGORY_ANY,
            TransformCategory::_3d => gsk_sys::GSK_TRANSFORM_CATEGORY_3D,
            TransformCategory::_2d => gsk_sys::GSK_TRANSFORM_CATEGORY_2D,
            TransformCategory::_2dAffine => gsk_sys::GSK_TRANSFORM_CATEGORY_2D_AFFINE,
            TransformCategory::_2dTranslate => gsk_sys::GSK_TRANSFORM_CATEGORY_2D_TRANSLATE,
            TransformCategory::Identity => gsk_sys::GSK_TRANSFORM_CATEGORY_IDENTITY,
            TransformCategory::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gsk_sys::GskTransformCategory> for TransformCategory {
    fn from_glib(value: gsk_sys::GskTransformCategory) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TransformCategory::Unknown,
            1 => TransformCategory::Any,
            2 => TransformCategory::_3d,
            3 => TransformCategory::_2d,
            4 => TransformCategory::_2dAffine,
            5 => TransformCategory::_2dTranslate,
            6 => TransformCategory::Identity,
            value => TransformCategory::__Unknown(value),
        }
    }
}

impl StaticType for TransformCategory {
    fn static_type() -> Type {
        unsafe { from_glib(gsk_sys::gsk_transform_category_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TransformCategory {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TransformCategory {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TransformCategory {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
