// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use gdk;
use gdk_sys;
use glib::object::IsA;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib_sys;
use gtk_sys;
use libc;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use EventController;
use Gesture;
use GestureSingle;

glib_wrapper! {
    pub struct DragSource(Object<gtk_sys::GtkDragSource, gtk_sys::GtkDragSourceClass, DragSourceClass>) @extends GestureSingle, Gesture, EventController;

    match fn {
        get_type => || gtk_sys::gtk_drag_source_get_type(),
    }
}

impl DragSource {
    pub fn new() -> DragSource {
        assert_initialized_main_thread!();
        unsafe { from_glib_full(gtk_sys::gtk_drag_source_new()) }
    }

    pub fn drag_cancel(&self) {
        unsafe {
            gtk_sys::gtk_drag_source_drag_cancel(self.to_glib_none().0);
        }
    }

    pub fn get_actions(&self) -> gdk::DragAction {
        unsafe { from_glib(gtk_sys::gtk_drag_source_get_actions(self.to_glib_none().0)) }
    }

    pub fn get_content(&self) -> Option<gdk::ContentProvider> {
        unsafe { from_glib_none(gtk_sys::gtk_drag_source_get_content(self.to_glib_none().0)) }
    }

    pub fn get_drag(&self) -> Option<gdk::Drag> {
        unsafe { from_glib_none(gtk_sys::gtk_drag_source_get_drag(self.to_glib_none().0)) }
    }

    pub fn set_actions(&self, actions: gdk::DragAction) {
        unsafe {
            gtk_sys::gtk_drag_source_set_actions(self.to_glib_none().0, actions.to_glib());
        }
    }

    pub fn set_content<P: IsA<gdk::ContentProvider>>(&self, content: Option<&P>) {
        unsafe {
            gtk_sys::gtk_drag_source_set_content(
                self.to_glib_none().0,
                content.map(|p| p.as_ref()).to_glib_none().0,
            );
        }
    }

    pub fn set_icon<P: IsA<gdk::Paintable>>(&self, paintable: Option<&P>, hot_x: i32, hot_y: i32) {
        unsafe {
            gtk_sys::gtk_drag_source_set_icon(
                self.to_glib_none().0,
                paintable.map(|p| p.as_ref()).to_glib_none().0,
                hot_x,
                hot_y,
            );
        }
    }

    pub fn connect_drag_begin<F: Fn(&DragSource, &gdk::Drag) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn drag_begin_trampoline<F: Fn(&DragSource, &gdk::Drag) + 'static>(
            this: *mut gtk_sys::GtkDragSource,
            drag: *mut gdk_sys::GdkDrag,
            f: glib_sys::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(drag))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"drag-begin\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    drag_begin_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    //pub fn connect_drag_cancel<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored reason: Gdk.DragCancelReason
    //}

    pub fn connect_drag_end<F: Fn(&DragSource, &gdk::Drag, bool) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn drag_end_trampoline<F: Fn(&DragSource, &gdk::Drag, bool) + 'static>(
            this: *mut gtk_sys::GtkDragSource,
            drag: *mut gdk_sys::GdkDrag,
            delete_data: glib_sys::gboolean,
            f: glib_sys::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(
                &from_glib_borrow(this),
                &from_glib_borrow(drag),
                from_glib(delete_data),
            )
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"drag-end\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    drag_end_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    pub fn connect_prepare<
        F: Fn(&DragSource, f64, f64) -> Option<gdk::ContentProvider> + 'static,
    >(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn prepare_trampoline<
            F: Fn(&DragSource, f64, f64) -> Option<gdk::ContentProvider> + 'static,
        >(
            this: *mut gtk_sys::GtkDragSource,
            x: libc::c_double,
            y: libc::c_double,
            f: glib_sys::gpointer,
        ) -> *mut gdk_sys::GdkContentProvider {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), x, y).to_glib_full()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"prepare\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    prepare_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    pub fn connect_property_actions_notify<F: Fn(&DragSource) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_actions_trampoline<F: Fn(&DragSource) + 'static>(
            this: *mut gtk_sys::GtkDragSource,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::actions\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_actions_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    pub fn connect_property_content_notify<F: Fn(&DragSource) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_content_trampoline<F: Fn(&DragSource) + 'static>(
            this: *mut gtk_sys::GtkDragSource,
            _param_spec: glib_sys::gpointer,
            f: glib_sys::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::content\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_content_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl Default for DragSource {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Display for DragSource {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "DragSource")
    }
}
