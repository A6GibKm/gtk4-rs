// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use TransformType;
use ffi;
use glib::GString;
use glib::translate::*;
use std::fmt;

glib_wrapper! {
    #[derive(Debug, PartialOrd, Ord, Hash)]
    pub struct Transform(Shared<ffi::GtkTransform>);

    match fn {
        ref => |ptr| ffi::gtk_transform_ref(ptr),
        unref => |ptr| ffi::gtk_transform_unref(ptr),
        get_type => || ffi::gtk_transform_get_type(),
    }
}

impl Transform {
    pub fn new() -> Transform {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gtk_transform_new())
        }
    }

    fn equal(&self, second: &Transform) -> bool {
        unsafe {
            from_glib(ffi::gtk_transform_equal(self.to_glib_none().0, second.to_glib_none().0))
        }
    }

    pub fn get_next(&self) -> Option<Transform> {
        unsafe {
            from_glib_none(ffi::gtk_transform_get_next(self.to_glib_none().0))
        }
    }

    pub fn get_transform_type(&self) -> TransformType {
        unsafe {
            from_glib(ffi::gtk_transform_get_transform_type(self.to_glib_none().0))
        }
    }

    pub fn identity(&self) -> Option<Transform> {
        unsafe {
            from_glib_full(ffi::gtk_transform_identity(self.to_glib_none().0))
        }
    }

    //pub fn matrix(&self, matrix: /*Ignored*/&graphene::Matrix) -> Option<Transform> {
    //    unsafe { TODO: call ffi::gtk_transform_matrix() }
    //}

    //pub fn print(&self, string: /*Ignored*/&mut glib::String) {
    //    unsafe { TODO: call ffi::gtk_transform_print() }
    //}

    pub fn rotate(&self, angle: f32) -> Option<Transform> {
        unsafe {
            from_glib_full(ffi::gtk_transform_rotate(self.to_glib_none().0, angle))
        }
    }

    //pub fn rotate_3d(&self, angle: f32, axis: /*Ignored*/&graphene::Vec3) -> Option<Transform> {
    //    unsafe { TODO: call ffi::gtk_transform_rotate_3d() }
    //}

    pub fn scale(&self, factor_x: f32, factor_y: f32) -> Option<Transform> {
        unsafe {
            from_glib_full(ffi::gtk_transform_scale(self.to_glib_none().0, factor_x, factor_y))
        }
    }

    pub fn scale_3d(&self, factor_x: f32, factor_y: f32, factor_z: f32) -> Option<Transform> {
        unsafe {
            from_glib_full(ffi::gtk_transform_scale_3d(self.to_glib_none().0, factor_x, factor_y, factor_z))
        }
    }

    //pub fn to_matrix(&self, out_matrix: /*Ignored*/graphene::Matrix) {
    //    unsafe { TODO: call ffi::gtk_transform_to_matrix() }
    //}

    fn to_string(&self) -> GString {
        unsafe {
            from_glib_full(ffi::gtk_transform_to_string(self.to_glib_none().0))
        }
    }

    pub fn transform(&self, other: Option<&Transform>) -> Option<Transform> {
        unsafe {
            from_glib_full(ffi::gtk_transform_transform(self.to_glib_full(), other.to_glib_none().0))
        }
    }

    //pub fn translate(&self, point: /*Ignored*/&graphene::Point) -> Option<Transform> {
    //    unsafe { TODO: call ffi::gtk_transform_translate() }
    //}

    //pub fn translate_3d(&self, point: /*Ignored*/&graphene::Point3D) -> Option<Transform> {
    //    unsafe { TODO: call ffi::gtk_transform_translate_3d() }
    //}
}

impl Default for Transform {
    fn default() -> Self {
        Self::new()
    }
}

impl PartialEq for Transform {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.equal(other)
    }
}

impl Eq for Transform {}

impl fmt::Display for Transform {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.to_string())
    }
}
